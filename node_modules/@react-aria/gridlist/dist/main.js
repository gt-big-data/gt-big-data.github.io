var $dSFus$reactariautils = require("@react-aria/utils");
var $dSFus$reactariagrid = require("@react-aria/grid");
var $dSFus$reactariaselection = require("@react-aria/selection");
var $dSFus$reactariafocus = require("@react-aria/focus");
var $dSFus$reactariainteractions = require("@react-aria/interactions");
var $dSFus$reactariai18n = require("@react-aria/i18n");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useGridList", () => $acf209ae814f1c93$export$664f9155035607eb);
$parcel$export(module.exports, "useGridListItem", () => $f7116f5928c03f32$export$9610e69494fadfd2);
$parcel$export(module.exports, "useGridListSelectionCheckbox", () => $43131ea217bc2ad3$export$e29f2573fabbf7b9);

const $7db02799adae605d$export$5b9bb410392e3991 = new WeakMap();
function $7db02799adae605d$export$f45c25170b9a99c2(state, key) {
    let { id: id  } = $7db02799adae605d$export$5b9bb410392e3991.get(state);
    if (!id) throw new Error('Unknown list');
    return `${id}-${$7db02799adae605d$export$e0c709538cb8ae18(key)}`;
}
function $7db02799adae605d$export$e0c709538cb8ae18(key) {
    if (typeof key === 'string') return key.replace(/\s*/g, '');
    return '' + key;
}




function $acf209ae814f1c93$export$664f9155035607eb(props, state, ref) {
    let { isVirtualized: isVirtualized , keyboardDelegate: keyboardDelegate , onAction: onAction  } = props;
    if (!props['aria-label'] && !props['aria-labelledby']) console.warn('An aria-label or aria-labelledby prop is required for accessibility.');
    let { listProps: listProps  } = $dSFus$reactariaselection.useSelectableList({
        selectionManager: state.selectionManager,
        collection: state.collection,
        disabledKeys: state.disabledKeys,
        ref: ref,
        keyboardDelegate: keyboardDelegate,
        isVirtualized: isVirtualized,
        selectOnFocus: state.selectionManager.selectionBehavior === 'replace'
    });
    let id = $dSFus$reactariautils.useId();
    $7db02799adae605d$export$5b9bb410392e3991.set(state, {
        id: id,
        onAction: onAction
    });
    let descriptionProps = $dSFus$reactariagrid.useHighlightSelectionDescription({
        selectionManager: state.selectionManager,
        hasItemActions: !!onAction
    });
    let domProps = $dSFus$reactariautils.filterDOMProps(props, {
        labelable: true
    });
    let gridProps = $dSFus$reactariautils.mergeProps(domProps, {
        role: 'grid',
        id: id,
        'aria-multiselectable': state.selectionManager.selectionMode === 'multiple' ? 'true' : undefined
    }, listProps, descriptionProps);
    if (isVirtualized) {
        gridProps['aria-rowcount'] = state.collection.size;
        gridProps['aria-colcount'] = 1;
    }
    $dSFus$reactariagrid.useGridSelectionAnnouncement({
    }, state);
    return {
        gridProps: gridProps
    };
}








function $f7116f5928c03f32$export$9610e69494fadfd2(props, state, ref) {
    // Copied from useGridCell + some modifications to make it not so grid specific
    let { node: node , isVirtualized: isVirtualized , shouldSelectOnPressUp: shouldSelectOnPressUp  } = props;
    let { direction: direction  } = $dSFus$reactariai18n.useLocale();
    let { onAction: onAction  } = $7db02799adae605d$export$5b9bb410392e3991.get(state);
    let descriptionId = $dSFus$reactariautils.useSlotId();
    let focus = ()=>{
        // Don't shift focus to the row if the active element is a element within the row already
        // (e.g. clicking on a row button)
        if (!ref.current.contains(document.activeElement)) $dSFus$reactariafocus.focusSafely(ref.current);
    };
    let { itemProps: itemProps , ...itemStates } = $dSFus$reactariaselection.useSelectableItem({
        selectionManager: state.selectionManager,
        key: node.key,
        ref: ref,
        isVirtualized: isVirtualized,
        shouldSelectOnPressUp: shouldSelectOnPressUp,
        onAction: onAction ? ()=>onAction(node.key)
         : undefined,
        focus: focus
    });
    let onKeyDown = (e)=>{
        if (!e.currentTarget.contains(e.target)) return;
        let walker = $dSFus$reactariafocus.getFocusableTreeWalker(ref.current);
        walker.currentNode = document.activeElement;
        switch(e.key){
            case 'ArrowLeft':
                {
                    // Find the next focusable element within the row.
                    let focusable = direction === 'rtl' ? walker.nextNode() : walker.previousNode();
                    if (focusable) {
                        e.preventDefault();
                        e.stopPropagation();
                        $dSFus$reactariafocus.focusSafely(focusable);
                    } else {
                        // If there is no next focusable child, then return focus back to the row
                        e.preventDefault();
                        e.stopPropagation();
                        if (direction === 'rtl') $dSFus$reactariafocus.focusSafely(ref.current);
                        else {
                            walker.currentNode = ref.current;
                            let lastElement = $f7116f5928c03f32$var$last(walker);
                            if (lastElement) $dSFus$reactariafocus.focusSafely(lastElement);
                        }
                    }
                    break;
                }
            case 'ArrowRight':
                {
                    let focusable = direction === 'rtl' ? walker.previousNode() : walker.nextNode();
                    if (focusable) {
                        e.preventDefault();
                        e.stopPropagation();
                        $dSFus$reactariafocus.focusSafely(focusable);
                    } else {
                        e.preventDefault();
                        e.stopPropagation();
                        if (direction === 'ltr') $dSFus$reactariafocus.focusSafely(ref.current);
                        else {
                            walker.currentNode = ref.current;
                            let lastElement = $f7116f5928c03f32$var$last(walker);
                            if (lastElement) $dSFus$reactariafocus.focusSafely(lastElement);
                        }
                    }
                    break;
                }
            case 'ArrowUp':
            case 'ArrowDown':
                // Prevent this event from reaching row children, e.g. menu buttons. We want arrow keys to navigate
                // to the row above/below instead. We need to re-dispatch the event from a higher parent so it still
                // bubbles and gets handled by useSelectableCollection.
                if (!e.altKey && ref.current.contains(e.target)) {
                    e.stopPropagation();
                    e.preventDefault();
                    ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));
                }
                break;
        }
    };
    let onFocus = (e)=>{
        if (e.target !== ref.current) {
            // useSelectableItem only handles setting the focused key when
            // the focused element is the row itself. We also want to
            // set the focused key when a child element receives focus.
            // If focus is currently visible (e.g. the user is navigating with the keyboard),
            // then skip this. We want to restore focus to the previously focused row
            // in that case since the list should act like a single tab stop.
            if (!$dSFus$reactariainteractions.isFocusVisible()) state.selectionManager.setFocusedKey(node.key);
            return;
        }
    };
    let rowProps = $dSFus$reactariautils.mergeProps(itemProps, {
        role: 'row',
        onKeyDownCapture: onKeyDown,
        onFocus: onFocus,
        'aria-label': node.textValue || undefined,
        'aria-selected': state.selectionManager.canSelectItem(node.key) ? state.selectionManager.isSelected(node.key) : undefined,
        'aria-disabled': state.selectionManager.isDisabled(node.key) || undefined,
        'aria-labelledby': descriptionId && node.textValue ? `${$7db02799adae605d$export$f45c25170b9a99c2(state, node.key)} ${descriptionId}` : undefined,
        id: $7db02799adae605d$export$f45c25170b9a99c2(state, node.key)
    });
    if (isVirtualized) rowProps['aria-rowindex'] = node.index + 1;
    let gridCellProps = {
        role: 'gridcell',
        'aria-colindex': 1
    };
    return {
        rowProps: rowProps,
        gridCellProps: gridCellProps,
        descriptionProps: {
            id: descriptionId
        },
        ...itemStates
    };
}
function $f7116f5928c03f32$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last)
    return next;
}




function $43131ea217bc2ad3$export$e29f2573fabbf7b9(props, state) {
    let { key: key  } = props;
    const { checkboxProps: checkboxProps  } = $dSFus$reactariagrid.useGridSelectionCheckbox(props, state);
    return {
        checkboxProps: {
            ...checkboxProps,
            'aria-labelledby': `${checkboxProps.id} ${$7db02799adae605d$export$f45c25170b9a99c2(state, key)}`
        }
    };
}




//# sourceMappingURL=main.js.map
