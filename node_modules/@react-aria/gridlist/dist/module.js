import {useId as $13Gtr$useId, filterDOMProps as $13Gtr$filterDOMProps, mergeProps as $13Gtr$mergeProps, useSlotId as $13Gtr$useSlotId} from "@react-aria/utils";
import {useHighlightSelectionDescription as $13Gtr$useHighlightSelectionDescription, useGridSelectionAnnouncement as $13Gtr$useGridSelectionAnnouncement, useGridSelectionCheckbox as $13Gtr$useGridSelectionCheckbox} from "@react-aria/grid";
import {useSelectableList as $13Gtr$useSelectableList, useSelectableItem as $13Gtr$useSelectableItem} from "@react-aria/selection";
import {focusSafely as $13Gtr$focusSafely, getFocusableTreeWalker as $13Gtr$getFocusableTreeWalker} from "@react-aria/focus";
import {isFocusVisible as $13Gtr$isFocusVisible} from "@react-aria/interactions";
import {useLocale as $13Gtr$useLocale} from "@react-aria/i18n";


const $ce9b18daab526bbd$export$5b9bb410392e3991 = new WeakMap();
function $ce9b18daab526bbd$export$f45c25170b9a99c2(state, key) {
    let { id: id  } = $ce9b18daab526bbd$export$5b9bb410392e3991.get(state);
    if (!id) throw new Error('Unknown list');
    return `${id}-${$ce9b18daab526bbd$export$e0c709538cb8ae18(key)}`;
}
function $ce9b18daab526bbd$export$e0c709538cb8ae18(key) {
    if (typeof key === 'string') return key.replace(/\s*/g, '');
    return '' + key;
}




function $f47efb0c3a859cf2$export$664f9155035607eb(props, state, ref) {
    let { isVirtualized: isVirtualized , keyboardDelegate: keyboardDelegate , onAction: onAction  } = props;
    if (!props['aria-label'] && !props['aria-labelledby']) console.warn('An aria-label or aria-labelledby prop is required for accessibility.');
    let { listProps: listProps  } = $13Gtr$useSelectableList({
        selectionManager: state.selectionManager,
        collection: state.collection,
        disabledKeys: state.disabledKeys,
        ref: ref,
        keyboardDelegate: keyboardDelegate,
        isVirtualized: isVirtualized,
        selectOnFocus: state.selectionManager.selectionBehavior === 'replace'
    });
    let id = $13Gtr$useId();
    $ce9b18daab526bbd$export$5b9bb410392e3991.set(state, {
        id: id,
        onAction: onAction
    });
    let descriptionProps = $13Gtr$useHighlightSelectionDescription({
        selectionManager: state.selectionManager,
        hasItemActions: !!onAction
    });
    let domProps = $13Gtr$filterDOMProps(props, {
        labelable: true
    });
    let gridProps = $13Gtr$mergeProps(domProps, {
        role: 'grid',
        id: id,
        'aria-multiselectable': state.selectionManager.selectionMode === 'multiple' ? 'true' : undefined
    }, listProps, descriptionProps);
    if (isVirtualized) {
        gridProps['aria-rowcount'] = state.collection.size;
        gridProps['aria-colcount'] = 1;
    }
    $13Gtr$useGridSelectionAnnouncement({
    }, state);
    return {
        gridProps: gridProps
    };
}








function $4e8b0456ef72939f$export$9610e69494fadfd2(props, state, ref) {
    // Copied from useGridCell + some modifications to make it not so grid specific
    let { node: node , isVirtualized: isVirtualized , shouldSelectOnPressUp: shouldSelectOnPressUp  } = props;
    let { direction: direction  } = $13Gtr$useLocale();
    let { onAction: onAction  } = $ce9b18daab526bbd$export$5b9bb410392e3991.get(state);
    let descriptionId = $13Gtr$useSlotId();
    let focus = ()=>{
        // Don't shift focus to the row if the active element is a element within the row already
        // (e.g. clicking on a row button)
        if (!ref.current.contains(document.activeElement)) $13Gtr$focusSafely(ref.current);
    };
    let { itemProps: itemProps , ...itemStates } = $13Gtr$useSelectableItem({
        selectionManager: state.selectionManager,
        key: node.key,
        ref: ref,
        isVirtualized: isVirtualized,
        shouldSelectOnPressUp: shouldSelectOnPressUp,
        onAction: onAction ? ()=>onAction(node.key)
         : undefined,
        focus: focus
    });
    let onKeyDown = (e)=>{
        if (!e.currentTarget.contains(e.target)) return;
        let walker = $13Gtr$getFocusableTreeWalker(ref.current);
        walker.currentNode = document.activeElement;
        switch(e.key){
            case 'ArrowLeft':
                {
                    // Find the next focusable element within the row.
                    let focusable = direction === 'rtl' ? walker.nextNode() : walker.previousNode();
                    if (focusable) {
                        e.preventDefault();
                        e.stopPropagation();
                        $13Gtr$focusSafely(focusable);
                    } else {
                        // If there is no next focusable child, then return focus back to the row
                        e.preventDefault();
                        e.stopPropagation();
                        if (direction === 'rtl') $13Gtr$focusSafely(ref.current);
                        else {
                            walker.currentNode = ref.current;
                            let lastElement = $4e8b0456ef72939f$var$last(walker);
                            if (lastElement) $13Gtr$focusSafely(lastElement);
                        }
                    }
                    break;
                }
            case 'ArrowRight':
                {
                    let focusable = direction === 'rtl' ? walker.previousNode() : walker.nextNode();
                    if (focusable) {
                        e.preventDefault();
                        e.stopPropagation();
                        $13Gtr$focusSafely(focusable);
                    } else {
                        e.preventDefault();
                        e.stopPropagation();
                        if (direction === 'ltr') $13Gtr$focusSafely(ref.current);
                        else {
                            walker.currentNode = ref.current;
                            let lastElement = $4e8b0456ef72939f$var$last(walker);
                            if (lastElement) $13Gtr$focusSafely(lastElement);
                        }
                    }
                    break;
                }
            case 'ArrowUp':
            case 'ArrowDown':
                // Prevent this event from reaching row children, e.g. menu buttons. We want arrow keys to navigate
                // to the row above/below instead. We need to re-dispatch the event from a higher parent so it still
                // bubbles and gets handled by useSelectableCollection.
                if (!e.altKey && ref.current.contains(e.target)) {
                    e.stopPropagation();
                    e.preventDefault();
                    ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));
                }
                break;
        }
    };
    let onFocus = (e)=>{
        if (e.target !== ref.current) {
            // useSelectableItem only handles setting the focused key when
            // the focused element is the row itself. We also want to
            // set the focused key when a child element receives focus.
            // If focus is currently visible (e.g. the user is navigating with the keyboard),
            // then skip this. We want to restore focus to the previously focused row
            // in that case since the list should act like a single tab stop.
            if (!$13Gtr$isFocusVisible()) state.selectionManager.setFocusedKey(node.key);
            return;
        }
    };
    let rowProps = $13Gtr$mergeProps(itemProps, {
        role: 'row',
        onKeyDownCapture: onKeyDown,
        onFocus: onFocus,
        'aria-label': node.textValue || undefined,
        'aria-selected': state.selectionManager.canSelectItem(node.key) ? state.selectionManager.isSelected(node.key) : undefined,
        'aria-disabled': state.selectionManager.isDisabled(node.key) || undefined,
        'aria-labelledby': descriptionId && node.textValue ? `${$ce9b18daab526bbd$export$f45c25170b9a99c2(state, node.key)} ${descriptionId}` : undefined,
        id: $ce9b18daab526bbd$export$f45c25170b9a99c2(state, node.key)
    });
    if (isVirtualized) rowProps['aria-rowindex'] = node.index + 1;
    let gridCellProps = {
        role: 'gridcell',
        'aria-colindex': 1
    };
    return {
        rowProps: rowProps,
        gridCellProps: gridCellProps,
        descriptionProps: {
            id: descriptionId
        },
        ...itemStates
    };
}
function $4e8b0456ef72939f$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last)
    return next;
}




function $e52ffc04a4adbd52$export$e29f2573fabbf7b9(props, state) {
    let { key: key  } = props;
    const { checkboxProps: checkboxProps  } = $13Gtr$useGridSelectionCheckbox(props, state);
    return {
        checkboxProps: {
            ...checkboxProps,
            'aria-labelledby': `${checkboxProps.id} ${$ce9b18daab526bbd$export$f45c25170b9a99c2(state, key)}`
        }
    };
}




export {$f47efb0c3a859cf2$export$664f9155035607eb as useGridList, $4e8b0456ef72939f$export$9610e69494fadfd2 as useGridListItem, $e52ffc04a4adbd52$export$e29f2573fabbf7b9 as useGridListSelectionCheckbox};
//# sourceMappingURL=module.js.map
